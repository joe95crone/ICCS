#================================================================# AUTHORS: E. Johnson, R. Kelmar and B. Terzic (August 2016)# PURPOSE: Compute backscattered spectra for the Duke Compton # source as shown in Sun et al. 2009 (PR STAB 12, 062801) Fig. 2#================================================================from math import pi,sqrt,cos,sin,atan,eimport matplotlib.pyplot as pltfrom scipy.integrate import dblquadimport numpy as npimport randomimport multiprocessing as mpimport timeimport sysplotOnly = int(sys.argv[1])   # comm. lin. arg: 1: plot only, <> compute & plotNpart = int(sys.argv[2])      # comm. lin. arg: 2: # of particle plottedAfac = float(sys.argv[3])     # comm. lin. arg: 3: aperture#----------------------------------------------------------------# Read in momentum values from file#----------------------------------------------------------------def mewantlist (Location, Column1, Column2, Column3):        """mewantlist produces a list of lists, where the lists are the         chosen columns of data        takes three indexes for desired columns"""        column1=[]        crs=open(Location,"r")        Np = 0        for columns in (raw.strip().split()                 for raw in crs):                        number1=columns[Column1]                        number2=columns[Column2]                        number3=columns[Column3]                        column1.append([number1,number2,number3])                        Np = Np + 1        return column1, Npp, Np = mewantlist('data.in',0,1,2)#----------------------------------------------------------------# Define physical constants#----------------------------------------------------------------hbar = 6.582e-16          # Planck's constant (eV*s)e0 = 8.85e-12             # epsilon 0 (C^2/Nm^2)c = 2.998e8               # speed of light (m/s)me = 9.109e-31            # electron mass (kg)r = 2.818e-15             # electron radius (m)ec = 511e3                # electron rest energy (eV)q = 1.602e-19             # electron charge (C)eVtoJ = 1.602176565e-19   # eV to Joules conversion#----------------------------------------------------------------# Compute mean energy of the distribution#----------------------------------------------------------------En0 = 0#Np = len(p[:][1])for n in range(0, Np):    En0 = En0 + sqrt((c**2)*(float(p[n][0])**2 + float(p[n][1])**2                       + float(p[n][2])**2 + (me*c)**2))/eVtoJEn0 = En0/Npgamma0=En0/ecprint "Reading ", Np, " particles from the distribution"print "Computed mean energy En0 = ", En0, " eV  (gamma_0 = ",gamma0, ")"#================================================================# COMPTON SCATTERING PARAMETERS: OK to edit#----------------------------------------------------------------L = 1e-9            # lambda: peak laser wavelength [m]a0 = 0.0134           # field strength parameter [no units]Aper = Afac/(10.0*gamma0)start = 0.0113      # starting point in sampling of E_gamma [MeV]Range = 0.0012      # range in sampling of E_gamma [MeV]s = 200             # laser pulse parameter [no units]pmag0 = (eVtoJ/c)*sqrt(En0**2-ec**2)  # (kg m/s)#----------------------------------------------------------------# Define Loop Iterations#----------------------------------------------------------------Nomegap = 300       # resolution for omega prime #----------------------------------------------------------------# Predict the amplitude of the peak (if aperture is big enough)#----------------------------------------------------------------alpha = 1.0/137.0gamma = En0/ecbeta = sqrt(1.0-1.0/(gamma**2))om0 = 2.0*pi*c/Lmt = om0*(hbar*eVtoJ)/(gamma*me*(c**2))omega_max = om0*(1+beta)/(1-beta+2*mt)E_max = hbar*omega_maxAmp = pi*alpha*(a0**2)*sqrt(pi)*s/E_maxprint "Aperture: ", Aperprint "Expected maximum amplitude Amp = ", Amp#================================================================#================================================================# ELECTRIC FIELD: OK to edit#----------------------------------------------------------------# E of omega` is the equation for the modified electric field# of the wave packet.  The E function defined here is for a # Gaussian wave front, but it can be re-coded to solve the # equation for other wave shapes. x is the angular frequency # of incident photon.#----------------------------------------------------------------E1=(a0*c*me*s*L*sqrt(pi))/(q*(1.602*10**(-13))*sqrt(2)) # [MeVs/C]E2=(-((s*L)**2)/(2*c**2))                               # [s^2]E3=((2*pi*c)/L)                                         # [1/s]E4=(-(4*pi*(s**2)*L)/c)                                 # [s]E = lambda x: x*E1*e**(E2*(x-E3)**2)*(e**(x*E4)+1)      # [MeV/C]#================================================================#----------------------------------------------------------------# W is the angular frequency of the incident photon as a function # of the theta and phi angles of the scattered photon (t,p), and # the angular frequency of the scattered photon. dW is the # partial derivative of W in terms of the scattered frequency#----------------------------------------------------------------def W(x,y,z,tc,ph,wp,pm,g,B):    ts=sqrt(1.0-tc*tc)    return ((wp*(1-(B/pm)*(x*ts*cos(ph)+ y*ts*sin(ph)+ z                 *tc)))/(1+B*(z/pm)-((wp*hbar)/(g*ec))*(1+tc)))def dW(x,y,z,tc,ph,wp,pm,g,B):    ts=sqrt(1.0-tc*tc)    phc=cos(ph)    phs=sin(ph)    return (1+(B*z/pm)-((B/pm)*(x*ts*phc+y*ts*phs+z*tc))                -((((B**2)*z)/(pm**2))*(x*ts*phc+y*ts*                phs+z*tc)))/((1+((B*z)/pm)-((wp*hbar)/(g*ec))*                (1+tc))**2)#-----------------------------------------------------------------# DSX is the cross section of the scattering event as a function # of the theta and phi angles of the scattered photon (t,p), and # the angular frequency of the scattered photon.#-----------------------------------------------------------------def dsx0(x,y,z,tc,ph,wp,w,pm,g,B):    ts=sqrt(1.0-tc*tc)    return ((1+tc-((wp*hbar)/(g*ec))*(1+tc))/                        (1-(B/pm)*(x*ts*cos(ph)+y*ts*                        sin(ph)+z*tc)))**2def dsx1(tc,ph,wp,g,B):    return (1+tc-((wp*hbar)/(g*ec))*(1+tc))/(1+B)            def dsx2(x,y,z,tc,ph,g):    ts=sqrt(1.0-tc*tc)    phc=cos(ph)    return (2*(me*ts*phc)**2)/((g*me                    -(1/c)*(x*ts*phc+                    y*ts*sin(ph)+z*tc))**2)        def dsx3(x,y,z,tc,ph,g):    ts=sqrt(1.0-tc*tc)    phc=cos(ph)    return (((2*me)**2)*c*x*ts*(1+tc)*phc)/((me*                    g+(z/c))*(g*me*c-x*ts*phc-y*                    ts*sin(ph)-z*tc)**2)        def dsx4(x,y,z,tc,ph,g):    ts=sqrt(1.0-tc*tc)    return (2*(me*x*(1+tc))**2)/((g*me*c+z/c)*(g*me*                    c-x*ts*cos(ph)-y*ts*sin(ph)-z*                    tc))**2def DSX(x0, x1, x2, x3, x4, g, B):    return (0.5*(r/(g*(1+B)))**2)*x0*(x1+(1/x1)-x2+x3-x4)#-----------------------------------------------------------------# dE is the energy density specrtum of the scattering event as a # function of the electric field of thelaser pulse (EF), the # differential cross section (DX), scattered angular frequency (wp), # incident angular frequency (w), and the first derivative of the # incident angular frequency function in terms of the scattered # angular frequency dw).#-----------------------------------------------------------------dE1 = ((e0*1.602*(10**-7))/(2*pi*c*hbar))def dE(EF, DX, wp, w, dw):    return dE1*(abs(EF)**2)*DX*((wp/w)*dw)# Initialize arraysY = [0 for x in range(0, Nomegap)]       # sum of A indexed over Ws2dOmegap = Range/(Nomegap-1)def loopParticles(pmag0, results, Y, dOmegap, index):#        p0 = 0#        p1 = 0#        p2 = pmag0        p0 = float(p[index][0])        p1 = float(p[index][1])        p2 = float(p[index][2])        print "Particle ", index+1, "/", Npart," momenta: ", p0, p1, p2        pmag1 = sqrt(p0**2+p1**2+p2**2)  # electron momentum magnitude[kg*m/s]        g1 = sqrt(1+(pmag1/(me*c))**2)   # Lorentz factor of electron frame        B1 = pmag1/(g1*me*c)             # relativistic speed of electron frame                                         # ^^ Electron momentum magnitude        for n in range(0, Nomegap):            x2 = n * dOmegap + start            Ws2 = ((x2 * (10 ** 6)) / hbar)            yp = dblquad(lambda ctheta, phi: dE(E(W(p0,p1,p2,ctheta,phi,Ws2,pmag1,g1,B1))                                                ,DSX(dsx0(p0,p1,p2,ctheta,phi,Ws2                                                ,W(p0,p1,p2,ctheta,phi,Ws2                                                ,pmag1,g1,B1),pmag1,g1,B1)                                                ,dsx1(ctheta,phi,Ws2,g1,B1)                                                ,dsx2(p0,p1,p2,ctheta,phi,g1)                                                ,dsx3(p0,p1,p2,ctheta,phi,g1)                                                ,dsx4(p0,p1,p2,ctheta,phi,g1),g1,B1)                                                ,Ws2, W(p0,p1,p2,ctheta,phi,Ws2,pmag1,g1,B1)                                                ,dW(p0,p1,p2,ctheta,phi,Ws2,pmag1,g1,B1))                                                ,0,2*pi,lambda ctheta:cos(Aper),lambda ctheta:1.0)            yp = yp[0]            Y[n] += 2*yp      # times 2 to accommodate +/- omega; this is just +omega        return Yresults = []def logResult(result):    results.append(result)   if __name__ == '__main__':    if (plotOnly <> 1):        cpu = mp.cpu_count()           # number of CPUs available        print "Computing on ", cpu, " cores"        pool = mp.Pool(processes=cpu)  # parallel execute on cpu CPUs        for x in range(0, Npart):      # parallelize over Npart            pool.apply_async(loopParticles, args=(pmag0, results, Y, dOmegap, x)                            ,callback=logResult)        pool.close()        pool.join()                    # ends processes when completed        Y = [0 for x in range (0,Nomegap)]        for i in range(0, Nomegap):           for n in range(0, Npart):               Y[i] += results[n][i]## Collect x-y coordinates        xplotN=[]        yplotN=[]        yplotNn=[]        for i in range(0,Nomegap):            xval=1e3*((i*Range)/(Nomegap-1)+start)            xplotN.append(xval)            Y[i]=Y[i]/(1e3*xval)       # [1/eV]for dE/d\omega, comment this line out        Ynorm=1.0 #max(Y)        for i in range(0,Nomegap):            yplotN.append(Y[i]/Npart)            yplotNn.append(Y[i]/Ynorm) # NOT normalized to 1#            print xplotN[i], yplotN[i]#-----------------------------# Dump data to a file#-----------------------------        f  = open('output_' + str(Afac) + '.txt','w')        for i in range(0, Nomegap):            line = r'%15.8e  %15.8e  %15.8e' % (xplotN[i],yplotN[i],yplotNn[i])             f.write(line)            f.write('\n')        f.close()        Ynorm=max(yplotN)